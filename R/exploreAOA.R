#' Explore Area of Applicability
#'
#' @description
#' This function lets the user explore an calculated Area of Applicability object
#' interactively in an R shiny application. Depending on whether the parameter \code{LPD = TRUE}
#' was specified in the calculation of the \code{AOA}, the user can either explore the
#' \code{AOA} and \code{DI} layer or additionally explore the \code{LPD} and a reactive \code{neighbor-dependent
#' AOA layer}.
#' The functionality is very suitable for a first visual interpretation of the
#' Area of Applicability.
#'
#' @param aoa An R object of class \code{aoa} (generated by the \code{\link{aoa}} function).
#'
#' @details
#' Interpretation of results: If a location is very similar to the properties
#' of the training data it will have a low distance in the predictor variable space
#' (\code{DI} towards 0) while locations that are very different in their properties
#' will have a high \code{DI}.
#' Depending on a threshold for the DI, the location will either be classified as
#' \code{Inside AOA (1)} or \code{Outside AOA (0)}. The comparison is done for the nearest neighbor
#' of the training points in the predictor space. This can be seen in the \code{AOA} layer.
#' The \code{LPD} (Local Data Point Density) layer indicates the total number of training data points
#' for which the locations \code{DI} is smaller than the threshold, i.e. on how many similar training points the model was trained.
#' The fourth layer is based on the \code{LPD} layer and can be seen as a \code{neighbor-dependet AOA}. This layer extends the \code{AOA}
#' by a minimum number k of training data points for which the threshold condition must hold in order to be classified as \code{Indside AOA (1)}.
#'
#'
#'
#' @author
#' Fabian Schumacher
#' @references Meyer, H., Pebesma, E. (2021): Predicting into unknown space?
#' Estimating the area of applicability of spatial prediction models.
#' Methods in Ecology and Evolution 12: 1620-1633. \doi{10.1111/2041-210X.13650}

#' @examples
#' \dontrun{
#'
#' }
#' @export exploreAOA
#' @aliases exploreAOA


###################
# Define Function # ------------------------------------------------------------
###################

exploreAOA <- function(aoa) {
  ########################
  # Check function input # -----------------------------------------------------
  ########################

  # check for class 'aoa'_______________________________________________________
  if (!inherits(aoa, "aoa")) {
    stop("Your passed data is not of class 'aoa'")
  }


  #############
  # Load data # ----------------------------------------------------------------
  #############

  # define raster layers and layer names _______________________________________
  LPD_available <- "LPD" %in% names(aoa)
  parameters <- aoa$parameters
  rasterImages <- c()
  rasterImages$AOA <- raster(aoa$AOA)
  rasterImages$DI <- raster(aoa$DI)
  if (LPD_available) {
    rasterImages$LPD <- raster(aoa$LPD)
    rasterImages$AOA_LPD <- raster(aoa$AOA) # initialize with AOA
    layerNames <- c("AOA" = "AOA", "DI" = "DI", "LPD" = "LPD", "AOA (LPD-dependent)" = "AOA_LPD")
  } else {
    layerNames <- c("AOA", "DI")
  }


  # define legend props for the AOA, DI and LPD _________________________________
  legendProperties <- list(
    AOA = list(
      pal = NULL,
      colors = c("#000000", "#FFFFFF"),
      labels = c("Outside (0)", "Inside (1)"),
      values = raster::values(rasterImages$AOA),
      title = "AOA"
    ),
    DI = list(
      pal = colorNumeric(
        palette = "viridis",
        domain = raster::values(rasterImages$DI)
      ),
      colors = viridis(30),
      labels = NULL,
      values = raster::values(rasterImages$DI),
      title = "DI"
    )
  )
  if (LPD_available) {
    legendProperties <- list.append(
      legendProperties,
      LPD = list(
        pal = colorNumeric(
          palette = "viridis",
          domain = raster::values(rasterImages$LPD)
        ),
        colors = viridis(30),
        labels = NULL,
        values = raster::values(rasterImages$LPD),
        title = "LPD"
      )
    )
    legendProperties <- list.append(
      legendProperties,
      AOA_LPD = list(
        pal = NULL,
        colors = c("#000000", "#FFFFFF"),
        labels = c("Outside (0)", "Inside (1)"),
        values = raster::values(rasterImages$AOA),
        title = "AOA (k-dependent)"
      )
    )
  }


  # define model props and build data.frame from model props____________________
  if (LPD_available) {
    if (!is.null(parameters$avrgLPD)) {
      avrgLPD <- parameters$avrgLPD
    } else {
      avrgLPD <- NA
    }
    maxLPD <- parameters$maxLPD
    if (parameters$maxLPD < max(na.omit(raster::values(rasterImages$LPD)))) {
      maxLPD <- parameters$maxLPD
    } else {
      maxLPD <- max(na.omit(raster::values(rasterImages$LPD)))
    }
  }
  parameters <-
    c(
      c(parameters$threshold),
      c(parameters$scaleparam$dim[1]),
      c(parameters$method)
    )

  rownames <- c()
  if (LPD_available) {
    parameters <- append(parameters, c(maxLPD), 2)
    parameters <- append(parameters, c(avrgLPD), 3)
    rownames <- c("DI threshold", "Sample size", "Max. LPD", "Avrg trainLPD", "Distance method")
  } else {
    rownames <- c("DI threshold", "Sample size", "Distance method")
  }

  parameters_df <- data.frame(parameters)
  row.names(parameters_df) <- rownames

  parameters_df["DI threshold", ] <-
    round(as.numeric(parameters_df["DI threshold", ]), digits = 3)
  parameters_df["Sample size", ] <-
    as.integer(parameters_df["Sample size", ])
  if (parameters_df["Distance method", ] == "L2") {
    parameters_df["Distance method", ] <- "Euclidian Distance"
  } else if (parameters_df["Distance method", ] == "MD") {
    parameters_df["Distance method", ] <- "Mahalanobis Distance"
  }
  if (LPD_available) {
    parameters_df["Max. LPD", ] <-
      as.integer(parameters_df["Max. LPD", ])
    parameters_df["Avrg trainLPD", ] <-
      as.integer(parameters_df["Avrg trainLPD", ])
  }


  # define layer extend ________________________________________________________
  extent <- extent(rasterImages$AOA)
  ymin <- extent@ymin
  ymax <- extent@ymax
  xmin <- extent@xmin
  xmax <- extent@xmax

  # define marker icon _________________________________________________________
  xmark <- makeIcon(system.file("images","xmark.png",package="CAST"), iconWidth = 18, iconHeight = 18)



  #############
  # Define UI # ----------------------------------------------------------------
  #############

  ui <- bootstrapPage(
    tags$style(
      type = "text/css",
      "html, body {width:100%;height:100%; position: fixed; cursor: pointer;}"
    ),
    leafletOutput(
      outputId = "map",
      width = "100%",
      height = "100%"
    ),
    absolutePanel(
      top = 10,
      right = 10,
      width = 300,
      style = "background-color: white; padding: 10px; border-radius: 10px; opacity: 90%; box-shadow: 0px 0px 2px; z-index: 9999;",
      # draggable = TRUE,
      sliderInput(
        "opacity",
        "Opacity",
        min(0),
        max(1),
        value = 0.8,
        step = 0.01
      ),
      selectInput(
        "layerSelect", "Layer",
        layerNames
      ),
      downloadButton("downloadTiff", "Download GeoTiff")
    ),
    absolutePanel(
      tags$h5(style = "font-weight: bold;", "Model Props:"),
      tableOutput("modelProps"),
      top = 250,
      right = 10,
      width = 300,
      style = "background-color: white; padding: 10px; border-radius: 10px; opacity: 90%; box-shadow: 0px 0px 2px;",
      # draggable = TRUE,
    ),
    absolutePanel(
      top = 490,
      right = 10,
      width = 300,
      # draggable = TRUE,
      conditionalPanel(
        condition = "output.showPanel == 'clicked'",
        tableOutput("pixelValues"),
        style = "background-color: white; padding: 10px; border-radius: 10px; opacity: 90%; box-shadow: 0px 0px 2px;",
      ),
    ),
    if (LPD_available) {
      absolutePanel(
        top = 600,
        right = 10,
        width = 300,
        # draggable = TRUE,
        conditionalPanel(
          condition = "input.layerSelect == 'AOA_LPD'",
          sliderInput(
            "k",
            "k",
            min(1),
            max(maxLPD),
            value = 1,
            step = 1
          ),
          style = "background-color: white; padding: 10px; border-radius: 10px; opacity: 90%; box-shadow: 0px 0px 2px;",
        ),
      )
    },
    absolutePanel(
      bottom = 20,
      right = 10,
      width = 300,
      style = "background-color: white; padding: 10px; border-radius: 10px; opacity: 90%; box-shadow: 0px 0px 2px; z-index: 9999;",
      # draggable = TRUE
      fileInput("trainLocations", label = "Upload your training locations", multiple = FALSE, accept = c(".geojson", ".gpkg")),
      conditionalPanel(
        condition = "output.uploadHappened == 'yes'",
        checkboxInput("showTrainDat", "Show training locations")
      )
    )
  )


  #################
  # Define server # ------------------------------------------------------------
  #################

  server <- function(input, output, session) {
    # define reactive values ___________________________________________________
    rv <- reactiveValues(
      map = NULL,
      clickOccurred = "not clicked",
      AOA_LPD = rasterImages$AOA_LPD,
      uploadHappened = "no"
    )

    # define leaflet map outout ________________________________________________
    output$map <- renderLeaflet({
      rv$map <- leaflet(options = leafletOptions(minZoom = 2, maxZoom = 19)) %>%
        addTiles(group = "OSM") %>%
        addProviderTiles(providers$OpenStreetMap) %>%
        setMaxBounds(
          lng1 = xmin - 180,  # Minimum longitude
          lat1 = ymin - 90,   # Minimum latitude
          lng2 = xmax + 180,   # Maximum longitude
          lat2 = ymax + 90     # Maximum latitude
        ) %>%
        fitBounds(
          lng1 = xmin,
          lat1 = ymin,
          lng2 = xmax,
          lat2 = ymax
        )
      rv$map
    })


    # Code to run when either input$layerSelect, input$opacity or input$k changes _______
    observe({
      if (!is.null(rv$map) && !is.null(rasterImages[[input$layerSelect]])) {
        showPageSpinner()
        layerLegendProps <- legendProperties[[input$layerSelect]]
        if (input$layerSelect == "AOA_LPD") {
          rasterImages$AOA_LPD[rasterImages$LPD < input$k] <- 0
          rasterImages$AOA_LPD[rasterImages$LPD >= input$k] <- 1
          rv$AOA_LPD <- rasterImages$AOA_LPD
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(
              rv$AOA_LPD,
              colors = layerLegendProps$colors,
              opacity = input$opacity
            ) %>%
            addLegend(
              position = "bottomleft",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            )
        }
        if (is.null(layerLegendProps$pal)) {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(
              rasterImages[[input$layerSelect]],
              colors = layerLegendProps$colors,
              opacity = input$opacity
            ) %>%
            addLegend(
              position = "bottomleft",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            )
        } else {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(
              rasterImages[[input$layerSelect]],
              colors = layerLegendProps$colors,
              opacity = input$opacity
            ) %>%
            addLegend(
              position = "bottomleft",
              pal = layerLegendProps$pal,
              values = layerLegendProps$values,
              title = layerLegendProps$title
            )
        }
        hidePageSpinner()
      }
    })

    observeEvent(input$trainLocations, {
      rv$uploadHappened <- "yes"
      updateCheckboxInput(session, "showTrainDat", value = TRUE)
    })

    output$uploadHappened <- reactive({
      rv$uploadHappened
    })
    outputOptions(output, "uploadHappened", suspendWhenHidden = FALSE)

    observeEvent(input$showTrainDat, {
      if (input$showTrainDat == TRUE && rv$uploadHappened == "yes") {
          # Read the uploaded GeoJSON/GeoPackage file
          trainLocations <- st_read(input$trainLocations$datapath)
          trainLocations <- as_Spatial(trainLocations)

          # Add the GeoJSON data to the Leaflet map
          leafletProxy("map") %>%
            addCircleMarkers(data = trainLocations, group = "trainLocations", color = "red", stroke = FALSE, radius = 3, fillOpacity = 10)
      } else if(input$showTrainDat == FALSE && rv$uploadHappened == "yes") {
        leafletProxy("map") %>%
          clearGroup(group = "trainLocations")
      }
    })


    # render model props table _________________________________________________
    output$modelProps <- renderTable(
      {
        return(parameters_df)
      },
      width = "100%",
      align = "r",
      rownames = TRUE,
      colnames = FALSE,
      striped = TRUE
    )


    # map click handling _______________________________________________________
    observeEvent(input$map_click, {
      rv$clickOccurred <- "clicked"
      click <- input$map_click
      lng <- click$lng
      lat <- click$lat

      leafletProxy("map") %>%
        removeMarker(layerId = c("xmark")) %>%
        addMarkers(
          layerId = "xmark",
          lng = lng,
          lat = lat,
          icon = xmark
        )
    })

    output$showPanel <- reactive({
      rv$clickOccurred
    })
    outputOptions(output, "showPanel", suspendWhenHidden = FALSE)

    output$pixelValues <- renderTable(
      {
        click <- input$map_click
        if (is.null(click)) {
          return()
        }

        # get coordinates from click event
        lng <- click$lng
        lat <- click$lat

        # extract raster values
        AOA_value <- raster::extract(
          rasterImages$AOA,
          cbind(lng, lat)
        )
        DI_value <- raster::extract(
          rasterImages$DI,
          cbind(lng, lat)
        )
        if (LPD_available) {
          LPD_value <- raster::extract(
            rasterImages$LPD,
            cbind(lng, lat)
          )
          AOA_LPD_value <- raster::extract(
            rv$AOA_LPD,
            cbind(lng, lat)
          )
        }

        # write raster values to list
        values_list <-
          list(
            AOA = list(AOA_value),
            DI = list(DI_value)
          )
        if (LPD_available) {
          values_list <- list.append(values_list, LPD = LPD_value)
          values_list <- list.append(values_list, AOA_LPD = AOA_LPD_value)
        }

        # convert list to df
        values_list_df <- as.data.frame(do.call(cbind, values_list))

        # format AOA values for table output
        if (is.na(values_list_df$AOA)) {
          values_list_df$AOA <- values_list_df$AOA
        } else if (as.integer(values_list_df$AOA) == 0) {
          values_list_df$AOA <- "Outside"
        } else if (as.integer(values_list_df$AOA) == 1) {
          values_list_df$AOA <- "Inside"
        }


        if (LPD_available) {
          # fromat AOA_LPD values for table output
          if (is.na(values_list_df$AOA_LPD)) {
            values_list_df$AOA_LPD <- values_list_df$AOA_LPD
          } else if (as.integer(values_list_df$AOA_LPD) == 0) {
            values_list_df$AOA_LPD <- "Outside"
          } else if (as.integer(values_list_df$AOA_LPD) == 1) {
            values_list_df$AOA_LPD <- "Inside"
          }
          values_list_df$LPD <- as.integer(values_list_df$LPD)
        }

        # return data if available at click location
        if (!is.na(values_list_df$AOA)) {
          return(values_list_df)
        } else {
          return("No data available at this location")
        }
      },
      width = "100%",
      align = "l"
    )

    # download handler _________________________________________________________
    output$downloadTiff <- downloadHandler(
      filename = function() {
        paste0(input$layerSelect, ".tiff")
      },
      content = function(file) {
        # Generate and save your TIFF data to the file
        if (input$layerSelect == "AOA_LPD") {
          layer <- rv$AOA_LPD
        } else {
          layer <- rasterImages[[input$layerSelect]]
        }
        # layer <- rasterImages[[input$layerSelect]]
        raster::writeRaster(layer, filename = file, format = "GTiff")
      }
    )
  }


  ###############################
  # Create the Shiny app object # ----------------------------------------------
  ###############################

  shinyApp(ui, server)
}
